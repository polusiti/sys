<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>将棋ミニゲーム（点対称ランダム初期配置）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
  :root{
    --board-bg: #f5d28c;
    --grid: #9a6b2f;
    --sel: #4f46e5;
    --move: #10b981;
    --capture: #ef4444;
    --sente: #111827;
    --gote: #b91c1c;
  }
  * { box-sizing: border-box; }
  body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", Arial, sans-serif; background:#fafafa; }
  .toolbar{
    display:flex;justify-content:space-between;align-items:center;gap:.75rem;
    padding:.6rem .9rem;border-bottom:1px solid #e5e7eb;background:#fff;
    position:sticky;top:0;z-index:2;
  }
  .chk{ margin-left:.6rem; font-size:.9rem; }
  .wrap{ display:flex; gap:1rem; padding:1rem; align-items:flex-start; max-width:1200px; margin:0 auto; }
  .board{
    position:relative;
    width:min(90vmin,640px);
    aspect-ratio:1/1;
    background:var(--board-bg);
    border:6px solid var(--grid);
    border-radius:8px;
    box-shadow: 0 2px 10px rgba(0,0,0,.08);
    display:grid;
    grid-template-columns: repeat(9, 1fr);
    grid-template-rows: repeat(9, 1fr);
  }
  .cell{
    position:relative;border:1px solid rgba(0,0,0,.2);
    display:flex;align-items:center;justify-content:center;
    user-select:none; cursor:pointer;
  }
  .coord{
    position:absolute; font-size:.65rem; color:rgba(0,0,0,.45);
  }
  .coord.x{ right:2px; bottom:2px; }
  .coord.y{ left:2px; top:2px; }
  .piece{
    width:84%; height:84%;
    border-radius:10%/16%;
    display:flex; align-items:center; justify-content:center;
    font-weight:700; letter-spacing:.05em;
    background:#fff7ed; border:2px solid #c2410c;
    transform-origin:center center;
  }
  .piece.sente{ color:var(--sente); }
  .piece.gote{ color:var(--gote); transform: rotate(180deg); }
  .piece.promoted{ background:#fef3c7; border-color:#b45309; }
  .cell.selected { outline:3px solid var(--sel); outline-offset:-3px; }
  .cell.move { box-shadow: inset 0 0 0 4px rgba(16,185,129,.35); }
  .cell.capture { box-shadow: inset 0 0 0 4px rgba(239,68,68,.35); }

  .panel{
    min-width:260px; max-width:360px;
    border:1px solid #e5e7eb; border-radius:8px; padding:1rem; background:#fff;
  }
  .panel h3{ margin:.2rem 0 .6rem; }
  .legend{ display:flex; gap:1rem; align-items:center; margin-top:.6rem; }
  .legend .piece{ width:1.8rem; height:1.8rem; font-size:.9rem; }
  </style>
</head>
<body>
  <header class="toolbar">
    <div class="left">
      <button id="newGameBtn">新しい対局</button>
      <label class="chk"><input type="checkbox" id="shufflePawns"> 歩もシャッフル（同段内）</label>
      <label class="chk"><input type="checkbox" id="showCoords" checked> 座標表示</label>
    </div>
    <div class="right">
      <span id="turnInfo">先手番</span>
    </div>
  </header>

  <main class="wrap">
    <div id="board" class="board" aria-label="将棋盤 9x9"></div>
    <aside class="panel">
      <h3>説明</h3>
      <ul>
        <li>非「歩」駒は元の駒マスだけで入れ替え（空白からは出現しません）。</li>
        <li>歩は標準の段（3段目/7段目）据え置き。チェックを入れると段内シャッフル。</li>
        <li>配置は180°回転対称（点対称）。</li>
        <li>クリックで駒→移動先の順に選択。</li>
        <li>成りは任意（不成り不可のケースは自動で成り）。</li>
      </ul>
      <div class="legend">
        <div><span class="piece sente">先</span> 先手（黒）</div>
        <div><span class="piece gote">後</span> 後手（赤）</div>
      </div>
      <details>
        <summary>今後の拡張（提案）</summary>
        <ul>
          <li>王手判定と自殺手の禁止</li>
          <li>持ち駒ルール（打ち）と二歩・打ち歩詰め簡易判定</li>
          <li>棋譜記録、再現、エクスポート</li>
        </ul>
      </details>
    </aside>
  </main>

  <script>
  // Robust single-file version (no external JS/CSS fetch)
  (function(){
    'use strict';
    function ready(fn){
      if(document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', fn, { once:true });
      }else{ fn(); }
    }
    ready(() => {
      const boardEl = document.getElementById('board');
      const newBtn = document.getElementById('newGameBtn');
      const shufflePawnsChk = document.getElementById('shufflePawns');
      const showCoordsChk = document.getElementById('showCoords');
      const turnInfo = document.getElementById('turnInfo');

      if(!boardEl){ console.error('[shogi] #board not found'); return; }

      const SENTE='S', GOTE='G';
      const KANJI={ P:'歩', L:'香', N:'桂', S:'銀', G:'金', B:'角', R:'飛', K:'王' };
      const PROMO={ P:'+P', L:'+L', N:'+N', S:'+S', B:'+B', R:'+R' };
      const UNPROMOTE={ '+P':'P', '+L':'L', '+N':'N', '+S':'S', '+B':'B', '+R':'R' };
      const size=9;

      const state={ board:emptyBoard(), turn:SENTE, selected:null, moves:[] };

      function emptyBoard(){ return Array.from({length:size},()=>Array.from({length:size},()=>null)); }
      function clonePiece(p){ return p? {...p} : null; }
      function placePiece(board,x,y,p){ board[y][x]=p?clonePiece(p):null; }
      function sideToMove(){ return state.turn; }
      function oppositeSide(s){ return s===SENTE?GOTE:SENTE; }
      function isPromoted(p){ return p.type.startsWith('+'); }
      function baseType(p){ return isPromoted(p)? UNPROMOTE[p.type] : p.type; }
      function kanjiFor(p){
        const t=baseType(p);
        if(isPromoted(p)){ if(t==='B')return '馬'; if(t==='R')return '龍'; return '金'; }
        return KANJI[t];
      }

      function render(){
        boardEl.innerHTML='';
        for(let y=0;y<size;y++){
          for(let x=0;x<size;x++){
            const cell=document.createElement('div');
            cell.className='cell'; cell.dataset.x=x; cell.dataset.y=y;
            if(showCoordsChk?.checked){
              const cx=document.createElement('div'); cx.className='coord x'; cx.textContent=(9-x);
              const cy=document.createElement('div'); cy.className='coord y'; cy.textContent=(y+1);
              cell.appendChild(cx); cell.appendChild(cy);
            }
            const p=state.board[y][x];
            if(p){
              const el=document.createElement('div');
              el.className='piece ' + (p.side===SENTE?'sente':'gote') + (isPromoted(p)?' promoted':'');
              el.textContent=kanjiFor(p);
              cell.appendChild(el);
            }
            if(state.selected && state.selected.x===x && state.selected.y===y) cell.classList.add('selected');
            if(state.moves.some(m=>m.x===x && m.y===y)){
              const cap = state.board[y][x] && state.board[y][x].side !== sideToMove();
              cell.classList.add(cap?'capture':'move');
            }
            cell.addEventListener('click', onCellClick);
            boardEl.appendChild(cell);
          }
        }
        if(turnInfo) turnInfo.textContent = sideToMove()===SENTE ? '先手番' : '後手番';
      }

      function standardBoard(){
        const b=emptyBoard();
        const back=['L','N','S','G','K','G','S','N','L'];
        for(let x=0;x<9;x++) placePiece(b,x,8,{type:back[x],side:SENTE});
        placePiece(b,1,7,{type:'B',side:SENTE});
        placePiece(b,7,7,{type:'R',side:SENTE});
        for(let x=0;x<9;x++) placePiece(b,x,6,{type:'P',side:SENTE});
        for(let x=0;x<9;x++) placePiece(b,8-x,0,{type:back[x],side:GOTE});
        placePiece(b,7,1,{type:'B',side:GOTE});
        placePiece(b,1,1,{type:'R',side:GOTE});
        for(let x=0;x<9;x++) placePiece(b,x,2,{type:'P',side:GOTE});
        return b;
      }

      function generateVariant({shufflePawns=false}={}){
        const base=standardBoard();
        const b=emptyBoard();
        const nonPawnSquares=[];
        for(let x=0;x<9;x++) nonPawnSquares.push({x,y:8});
        nonPawnSquares.push({x:1,y:7},{x:7,y:7});

        const pool=[];
        nonPawnSquares.forEach(({x,y})=>{
          const p=base[y][x]; if(p && p.type!=='P') pool.push(p.type);
        });
        shuffleInPlace(pool);
        nonPawnSquares.forEach(({x,y},i)=> placePiece(b,x,y,{type:pool[i],side:SENTE}));

        const files=[0,1,2,3,4,5,6,7,8];
        if(shufflePawns) shuffleInPlace(files);
        files.forEach(x=> placePiece(b,x,6,{type:'P',side:SENTE}));

        // mirror
        for(let y=0;y<9;y++){
          for(let x=0;x<9;x++){
            const sp=b[y][x];
            if(sp){ placePiece(b,8-x,8-y,{type:sp.type,side:GOTE}); }
          }
        }
        return b;
      }

      function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } }

      function generateMoves(x,y){
        const p=state.board[y][x]; if(!p) return [];
        const dir = (p.side===SENTE? -1 : 1);
        const moves=[];
        function pushStep(nx,ny){
          if(nx<0||nx>=9||ny<0||ny>=9) return;
          const t=state.board[ny][nx];
          if(!t){ moves.push({x:nx,y:ny,capture:false}); return true; }
          else if(t.side!==p.side){ moves.push({x:nx,y:ny,capture:true}); }
          return false;
        }
        function slide(dx,dy){
          let nx=x+dx, ny=y+dy;
          while(nx>=0&&nx<9&&ny>=0&&ny<9){
            const cont=pushStep(nx,ny);
            if(cont===false) break;
            const has=state.board[ny][nx]!=null;
            if(has) break;
            nx+=dx; ny+=dy;
          }
        }
        const t=baseType(p), promoted=isPromoted(p);
        if(t==='K'){
          for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]) pushStep(x+dx,y+dy);
        }else if(t==='G' || (promoted && ['P','L','N','S'].includes(t))){
          const del = p.side===SENTE? [[0,-1],[1,0],[-1,0],[0,1],[1,-1],[-1,-1]] : [[0,1],[1,0],[-1,0],[0,-1],[1,1],[-1,1]];
          for(const [dx,dy] of del) pushStep(x+dx,y+dy);
        }else if(t==='S' && !promoted){
          const del = p.side===SENTE? [[0,-1],[1,-1],[-1,-1],[1,1],[-1,1]] : [[0,1],[1,1],[-1,1],[1,-1],[-1,-1]];
          for(const [dx,dy] of del) pushStep(x+dx,y+dy);
        }else if(t==='N' && !promoted){
          for(const [dx,dy] of (p.side===SENTE? [[-1,-2],[1,-2]] : [[-1,2],[1,2]])) pushStep(x+dx,y+dy);
        }else if(t==='L' && !promoted){
          slide(0,dir);
        }else if(t==='P' && !promoted){
          pushStep(x,y+dir);
        }else if(t==='B'){
          slide(1,1); slide(1,-1); slide(-1,1); slide(-1,-1);
          if(promoted){ pushStep(x+1,y); pushStep(x-1,y); pushStep(x,y+1); pushStep(x,y-1); }
        }else if(t==='R'){
          slide(1,0); slide(-1,0); slide(0,1); slide(0,-1);
          if(promoted){ pushStep(x+1,y+1); pushStep(x+1,y-1); pushStep(x-1,y+1); pushStep(x-1,y-1); }
        }

        const zoneY = (p.side===SENTE)? [0,1,2] : [6,7,8];
        const inZone = (yy)=> zoneY.includes(yy);
        const mustPromote = (fromY,toY,base)=>{
          if(base==='P' || base==='L'){
            if((p.side===SENTE && toY===0) || (p.side===GOTE && toY===8)) return true;
          }
          if(base==='N'){
            if((p.side===SENTE && toY<=1) || (p.side===GOTE && toY>=7)) return true;
          }
          return false;
        };
        for(const m of moves){
          const base = baseType(p);
          const can = (inZone(y) || inZone(m.y)) && (['P','L','N','S','B','R'].includes(base)) && !isPromoted(p);
          m.promoteAllowed = !!can;
          m.promoteForced = can && mustPromote(y, m.y, base);
        }
        return moves;
      }

      function onCellClick(e){
        const x=Number(e.currentTarget.dataset.x);
        const y=Number(e.currentTarget.dataset.y);
        const b=state.board, sel=state.selected;
        if(b[y][x] && b[y][x].side===sideToMove()){
          state.selected={x,y};
          state.moves=generateMoves(x,y);
          render(); return;
        }
        if(sel){
          const mv=state.moves.find(m=>m.x===x && m.y===y);
          if(mv){
            moveSelectedTo(x,y,mv);
            state.selected=null; state.moves=[]; state.turn = oppositeSide(state.turn);
            render(); return;
          }
        }
        state.selected=null; state.moves=[]; render();
      }

      function moveSelectedTo(nx,ny,mvInfo){
        const {x,y}=state.selected;
        const p=clonePiece(state.board[y][x]);
        const tgt=state.board[ny][nx];
        if(tgt && tgt.side!==p.side){
          // TODO: 持ち駒化（MVPは除去）
        }
        if(mvInfo.promoteForced){ p.type=promoteType(p); }
        else if(mvInfo.promoteAllowed){ if(confirm('成りますか？')) p.type=promoteType(p); }
        placePiece(state.board,nx,ny,p);
        placePiece(state.board,x,y,null);
      }
      function promoteType(p){ const base=baseType(p); return PROMO[base] ?? p.type; }

      function newGame(){
        state.board = generateVariant({ shufflePawns: !!(shufflePawnsChk && shufflePawnsChk.checked) });
        state.turn=SENTE; state.selected=null; state.moves=[];
        render();
      }

      if(newBtn) newBtn.addEventListener('click', newGame);
      if(shufflePawnsChk) shufflePawnsChk.addEventListener('change', newGame);
      if(showCoordsChk) showCoordsChk.addEventListener('change', render);

      newGame();
    });
  })();
  </script>
</body>
</html>
