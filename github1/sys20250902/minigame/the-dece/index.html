<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Dece（2人＋CPU／非対称・心理推理）</title>
  <style>
    :root{
      --bg:#0b1220; --fg:#e5ecff; --muted:#93a4c8; --card:#0f172a; --accent:#22d3ee; --border:#1f2a44;
      --light:#e5f0ff; --dark:#99b3e6; --grid:#1f3a7a;
      --a:#10b981; --b:#ef4444; --c:#3b82f6; --mask:#cbd5e1; --treasure:#f59e0b;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f8fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --accent:#0891b2; --border:#e2e8f0;
        --light:#eef5ff; --dark:#cfe0ff; --grid:#315aa6;
        --a:#059669; --b:#dc2626; --c:#2563eb; --mask:#64748b; --treasure:#d97706;
      }
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
    }
    header{
      position: sticky; top:0; z-index: 1;
      display:flex; justify-content:space-between; align-items:center; gap:16px;
      padding:12px 16px; border-bottom:1px solid var(--border); background: color-mix(in oklab, var(--card), var(--bg) 20%);
    }
    .back{ color:inherit; text-decoration:none; opacity:.8; }
    .back:hover{ opacity:1; text-decoration:underline; }
    .btn{ background:var(--accent); color:white; border:0; padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
    .toggle{ background: transparent; color: var(--fg); border:1px solid var(--border); padding:6px 10px; border-radius:10px; cursor:pointer; }
    .pill{ padding:.15rem .5rem; border-radius:999px; background: color-mix(in oklab, var(--card), var(--bg) 30%); border:1px solid var(--border); }
    main.wrap{
      max-width:1100px; margin:0 auto; padding:16px; display:grid; gap:16px;
      grid-template-columns: minmax(320px, 1fr) 380px;
    }
    @media (max-width: 980px){ main.wrap{ grid-template-columns: 1fr; } }

    .board{
      display:grid; grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(5, 1fr);
      width:100%; max-width: min(94vw, 560px); aspect-ratio: 1 / 1;
      border-radius:14px; overflow:hidden; border:2px solid var(--grid);
      background: var(--grid); user-select:none; touch-action: manipulation;
      box-shadow: inset 0 0 0 6px var(--grid);
    }
    .cell{
      position: relative; display:flex; justify-content:center; align-items:center; cursor:pointer;
      background: var(--light);
      box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--grid), black 20%);
    }
    .cell.alt{ background: var(--dark); }
    .cell.move::before{
      content:''; position:absolute; width:34%; height:34%; border-radius:999px;
      box-shadow: 0 0 0 2px rgba(34,211,238,.9), inset 0 0 0 2px rgba(34,211,238,.9);
      background: rgba(34,211,238,.15);
    }
    .coord{ position:absolute; font-size:10px; opacity:.8; color:rgba(255,255,255,.85); mix-blend-mode: overlay; text-shadow: 0 1px 2px rgba(0,0,0,.5);}
    .coord.x{ left:4px; top:2px; }
    .coord.y{ right:4px; bottom:2px; }

    .token{
      display:flex; align-items:center; justify-content:center;
      width: 68%; height: 68%; border-radius:12px; font-weight:900; letter-spacing:.02em;
      color:white; text-shadow: 0 1px 0 rgba(0,0,0,.35);
      box-shadow: inset 0 2px 0 rgba(255,255,255,.2), inset 0 -2px 0 rgba(0,0,0,.2), 0 2px 4px rgba(0,0,0,.25);
      font-size: clamp(16px, 5vw, 28px);
    }
    .t-a{ background: var(--a); }
    .t-b{ background: var(--b); }
    .t-c{ background: var(--c); }
    .t-mask{ background: var(--mask); }

    .treasure{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
      color: var(--treasure); font-size: clamp(18px, 6vw, 30px); opacity:.9;
      text-shadow: 0 1px 0 rgba(0,0,0,.25);
    }
    .panel{
      background: var(--card); border:1px solid var(--border); border-radius:14px; padding:12px;
    }
    .panel h3{ margin:.2rem 0 0.6rem; font-size:1rem; }
    .muted{ color:var(--muted); }
    .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
    .legend{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:.95rem; }
    .dot{ width:12px; height:12px; border-radius:999px; display:inline-block; vertical-align:middle; margin-right:6px; }
    .d-a{ background: var(--a); } .d-b{ background: var(--b); } .d-c{ background: var(--c); } .d-mask{ background: var(--mask); }
    .d-t{ background: var(--treasure); }

    .status{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      padding:8px 10px; border-radius:10px; background: color-mix(in oklab, var(--card), var(--bg) 25%); border:1px solid var(--border);
    }
    .won{ color:#22c55e; font-weight:800; }
    .warn{ color:#f59e0b; font-weight:700; }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: color-mix(in oklab, var(--card), var(--bg) 30%); padding:.1rem .35rem; border-radius:6px; border:1px solid var(--border); }
  </style>
</head>
<body>
  <header>
    <a class="back" href="../index.html">← Minigame 一覧へ</a>
    <div class="legend">
      <span class="pill">視点: <strong id="persLabel">A（探索者）</strong></span>
      <button id="toggleViewBtn" class="toggle">視点を切替</button>
      <button id="newGameBtn" class="btn">新しいゲーム</button>
    </div>
  </header>

  <main class="wrap">
    <div>
      <div id="board" class="board" aria-label="The Dece 盤 5x5"></div>
      <div style="margin-top:10px" class="status">
        <span>ターン: <strong id="turnText">1</strong> / 15</span>
        <span>行動順: <strong id="orderText">A → B → CPU</strong></span>
        <span>手番: <strong id="actorText">A</strong></span>
        <span>残り: <strong id="timeLeft">6.0s</strong></span>
        <span id="msg" class="muted"></span>
      </div>
    </div>

    <aside class="panel">
      <h3>ゲーム概要</h3>
      <p class="muted">A（探索者）は15ターン以内に宝へ到達すると勝利。B（妨害者）は宝の位置を知っており、Aの到達を妨害。CPUはランダムに動く。</p>

      <h3>表示と操作</h3>
      <ul class="muted">
        <li>視点A: BとCPUは同じ見た目（秘匿）。宝は表示されません。</li>
        <li>視点B: B/CPUを識別、宝の位置（★）が表示されます。</li>
        <li>自分の手番のとき、盤の水色マーカーをクリックして移動。</li>
        <li>1手6秒の切れ負け。時間切れ時点でそのプレイヤーの負け。</li>
        <li>CPUの着手は1〜4秒のランダムディレイ（バレにくく調整）。</li>
        <li><span class="kbd">N</span> 新しいゲーム / <span class="kbd">V</span> 視点切替 / 移動不可時は <span class="kbd">Space</span> でパス</li>
      </ul>

      <h3>凡例</h3>
      <div class="legend">
        <span><span class="dot d-a"></span>A（探索者）</span>
        <span><span class="dot d-b"></span>B（妨害者・人間）</span>
        <span><span class="dot d-c"></span>CPU（ランダム）</span>
        <span><span class="dot d-mask"></span>視点AでのB/CPU表示</span>
        <span><span class="dot d-t"></span>宝（視点Bのみ表示）</span>
      </div>
    </aside>
  </main>

  <script>
  (function(){
    'use strict';
    function ready(fn){ if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', fn, {once:true}); } else { fn(); } }

    ready(() => {
      const size = 5;
      const MAX_TURNS = 15;
      const MOVE_LIMIT_MS = 6000; // 一手6秒

      const boardEl = document.getElementById('board');
      const persLabel = document.getElementById('persLabel');
      const toggleViewBtn = document.getElementById('toggleViewBtn');
      const newGameBtn = document.getElementById('newGameBtn');
      const turnText = document.getElementById('turnText');
      const orderText = document.getElementById('orderText');
      const actorText = document.getElementById('actorText');
      const timeLeftEl = document.getElementById('timeLeft');
      const msgEl = document.getElementById('msg');

      const state = {
        treasure: null, // {x,y}
        pos: { A:null, B:null, C:null }, // A:探索者, B:妨害者, C:CPU
        order: ['A','B','C'],
        phase: 0,   // 0..2 (行動順インデックス)
        turn: 1,    // 1..15
        perspective: 'A', // 'A' or 'B'
        gameOver: false,
        winner: null, // 'A' or 'B'
      };

      const timers = {
        deadline: 0,
        intervalId: null,
        timeoutId: null,
        cpuTimerId: null,
      };

      function key(x,y){ return `${x},${y}`; }
      function inBoard(x,y){ return x>=0 && x<size && y>=0 && y<size; }

      function rndInt(n){ return (Math.random()*n)|0; }
      function shuffleInPlace(a){
        for(let i=a.length-1;i>0;i--){
          const j=(Math.random()*(i+1))|0;
          [a[i],a[j]]=[a[j],a[i]];
        }
        return a;
      }

      function pickTreasure(){
        const x = rndInt(size), y = rndInt(size);
        return {x,y};
      }

      function pickDistinctPositions(excludeSet, count){
        const all=[];
        for(let y=0;y<size;y++){
          for(let x=0;x<size;x++){
            const k=key(x,y);
            if(!excludeSet.has(k)) all.push({x,y});
          }
        }
        shuffleInPlace(all);
        return all.slice(0,count);
      }

      function occupiedAt(x,y){
        for(const id of ['A','B','C']){
          const p = state.pos[id];
          if(p && p.x===x && p.y===y) return id;
        }
        return null;
      }

      function legalMoves(id){
        const me = state.pos[id];
        if(!me) return [];
        const deltas = [];
        if(id==='A'){
          for(let dx=-1; dx<=1; dx++){
            for(let dy=-1; dy<=1; dy++){
              if(dx===0 && dy===0) continue;
              deltas.push([dx,dy]);
            }
          }
        }else{ // B or C: 4方向のみ
          deltas.push([1,0],[-1,0],[0,1],[0,-1]);
        }
        const moves = [];
        for(const [dx,dy] of deltas){
          const nx=me.x+dx, ny=me.y+dy;
          if(!inBoard(nx,ny)) continue;
          if(occupiedAt(nx,ny)) continue; // 他のキャラがいるマス不可
          moves.push({x:nx,y:ny});
        }
        return moves;
      }

      function applyMove(id, to){
        const from = state.pos[id];
        if(!from) return false;
        if(!legalMoves(id).some(m=>m.x===to.x && m.y===to.y)) return false;
        state.pos[id] = {x:to.x, y:to.y};

        // Aが宝に到達したら即勝利
        if(id==='A' && state.pos.A.x===state.treasure.x && state.pos.A.y===state.treasure.y){
          state.gameOver = true;
          state.winner = 'A';
          return true;
        }
        return true;
      }

      function advancePhase(){
        state.phase++;
        if(state.phase >= state.order.length){
          state.phase = 0;
          state.turn++;
          if(!state.gameOver && state.turn > MAX_TURNS){
            state.gameOver = true;
            state.winner = 'B';
          }
        }
      }

      function actorNow(){
        return state.order[state.phase];
      }

      function actorLabel(id){
        return id==='A' ? 'A' : (id==='B' ? 'B' : 'CPU');
      }

      function clearTimers(){
        if(timers.intervalId){ clearInterval(timers.intervalId); timers.intervalId=null; }
        if(timers.timeoutId){ clearTimeout(timers.timeoutId); timers.timeoutId=null; }
        if(timers.cpuTimerId){ clearTimeout(timers.cpuTimerId); timers.cpuTimerId=null; }
      }

      function updateTimeLeft(){
        const now = performance.now();
        const remain = Math.max(0, timers.deadline - now);
        timeLeftEl.textContent = (remain/1000).toFixed(1) + 's';
      }

      function startMoveClock(){
        clearTimers();
        timers.deadline = performance.now() + MOVE_LIMIT_MS;
        updateTimeLeft();
        timers.intervalId = setInterval(updateTimeLeft, 100);
        timers.timeoutId = setTimeout(onMoveTimeout, MOVE_LIMIT_MS + 10);
      }

      function onMoveTimeout(){
        if(state.gameOver) return;
        const id = actorNow();
        // CPUは通常1-4秒に収まるが、スリープ等で遅延した場合の保険：即パス扱いで進行
        if(id === 'C'){
          const moves = legalMoves('C');
          if(moves.length){
            applyMove('C', moves[rndInt(moves.length)]);
          }
          clearTimers();
          advancePhase();
          startTurnCycle();
          return;
        }
        // 人間の時間切れは切れ負け
        state.gameOver = true;
        state.winner = (id==='A') ? 'B' : 'A';
        clearTimers();
        render();
      }

      function scheduleCpuMove(){
        // 1〜4秒のランダム（ミリ秒単位）
        const delay = 1000 + Math.random()*3000;
        timers.cpuTimerId = setTimeout(()=>{
          if(state.gameOver) return;
          if(actorNow() !== 'C') return; // 手番が変わっていたら無視
          const moves = legalMoves('C');
          if(moves.length){
            const m = moves[rndInt(moves.length)];
            applyMove('C', m);
          }
          clearTimers(); // この手の時計を停止
          // 次へ
          advancePhase();
          startTurnCycle();
        }, delay);
      }

      function startTurnCycle(){
        render();
        if(state.gameOver) return;

        // 新しい手の時計を開始
        startMoveClock();

        const id = actorNow();
        if(id === 'C'){
          msgEl.textContent = 'CPU思考中…';
          msgEl.classList.remove('warn');
          scheduleCpuMove();
        }else{
          // 人間手番：何もしない（クリック待ち）。移動不可でも時間内にパスしないと切れ負け。
          if(legalMoves(id).length===0){
            msgEl.textContent = '移動可能マスなし：Spaceでパス（切れ負け注意）';
            msgEl.classList.add('warn');
          }else{
            msgEl.textContent = '';
            msgEl.classList.remove('warn');
          }
        }
      }

      function startNewGame(){
        clearTimers();
        state.treasure = pickTreasure();

        // 初期配置は宝マスを除外して3者をランダム配置（被り回避）
        const ex = new Set([key(state.treasure.x, state.treasure.y)]);
        const [pA, pB, pC] = pickDistinctPositions(ex, 3);
        state.pos.A = pA; state.pos.B = pB; state.pos.C = pC;

        // 行動順はA/B/Cをランダムに並べ替え、以後固定
        state.order = shuffleInPlace(['A','B','C']);
        state.phase = 0;
        state.turn = 1;
        state.perspective = 'A'; // デフォルトはA視点
        state.gameOver = false;
        state.winner = null;

        startTurnCycle();
      }

      function handleCellClick(e){
        if(state.gameOver) return;
        const id = actorNow();
        if(id==='C') return; // CPU手番は入力不可
        const x = parseInt(e.currentTarget.dataset.x,10);
        const y = parseInt(e.currentTarget.dataset.y,10);
        if(!legalMoves(id).some(m=>m.x===x && m.y===y)) return;

        applyMove(id, {x,y});
        clearTimers();
        if(!state.gameOver){
          advancePhase();
          startTurnCycle();
        }else{
          render();
        }
      }

      function render(){
        // ラベル系
        persLabel.textContent = state.perspective==='A' ? 'A（探索者）' : 'B（妨害者）';
        turnText.textContent = String(Math.min(state.turn, MAX_TURNS)) + (state.turn>MAX_TURNS?'（終了）':'');
        orderText.textContent = state.order.map(actorLabel).join(' → ');

        if(state.gameOver){
          actorText.textContent = '-';
          msgEl.classList.remove('warn');
          msgEl.classList.add('won');
          msgEl.textContent = state.winner==='A' ? 'Aの勝ち（宝に到達／相手切れ）' : 'Bの勝ち（15ターン経過／相手切れ）';
        }else{
          actorText.textContent = actorLabel(actorNow());
          msgEl.classList.remove('won');
        }

        // 盤描画
        boardEl.innerHTML = '';
        const idNow = actorNow();
        const humanTurn = (!state.gameOver && idNow!=='C');
        const humanMoves = humanTurn ? legalMoves(idNow) : [];

        for(let y=0;y<size;y++){
          for(let x=0;x<size;x++){
            const cell = document.createElement('div');
            cell.className = 'cell' + (((x+y)&1)?' alt':'');
            cell.dataset.x = x; cell.dataset.y = y;

            // 座標
            const cx = document.createElement('div');
            cx.className='coord x'; cx.textContent = String.fromCharCode(65 + x);
            const cy = document.createElement('div');
            cy.className='coord y'; cy.textContent = String(size - y);
            cell.appendChild(cx); cell.appendChild(cy);

            // 視点Bのみ宝表示
            if(state.perspective==='B' && state.treasure.x===x && state.treasure.y===y){
              const t = document.createElement('div');
              t.className='treasure';
              t.textContent = '★';
              cell.appendChild(t);
            }

            // 駒描画（視点AではBとCを同じ見た目に）
            const occ = occupiedAt(x,y);
            if(occ){
              const token = document.createElement('div');
              if(occ==='A'){ token.className = 'token t-a'; token.textContent = 'A'; }
              else if(state.perspective==='A'){ token.className = 'token t-mask'; token.textContent = '■'; }
              else if(occ==='B'){ token.className = 'token t-b'; token.textContent = 'B'; }
              else { token.className = 'token t-c'; token.textContent = 'CPU'; }
              cell.appendChild(token);
            }else{
              // 空きマス：自分の手番かつ合法手ならマーキング
              if(humanTurn && humanMoves.some(m=>m.x===x && m.y===y)){
                cell.classList.add('move');
              }
            }

            cell.addEventListener('click', handleCellClick);
            boardEl.appendChild(cell);
          }
        }
        // 表示だけ先に更新
        updateTimeLeft();
      }

      // Controls
      toggleViewBtn.addEventListener('click', ()=>{
        state.perspective = (state.perspective==='A' ? 'B' : 'A');
        render();
      });
      newGameBtn.addEventListener('click', startNewGame);
      window.addEventListener('keydown', (e)=>{
        if(e.key==='v' || e.key==='V'){ state.perspective = (state.perspective==='A' ? 'B' : 'A'); render(); }
        if(e.key==='n' || e.key==='N'){ startNewGame(); }
        // 人間手番で移動可能マスが無い場合はパス（スペース）
        if((e.key===' ' || e.code==='Space') && !state.gameOver){
          const id = actorNow();
          if(id!=='C' && legalMoves(id).length===0){
            clearTimers();
            advancePhase();
            startTurnCycle();
          }
        }
      });

      // 初期開始
      startNewGame();
    });
  })();
  </script>
</body>
</html>
